<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../utils/fetch.html">
<link rel="import" href="../utils/lodash.html">

<script>
    class SpotifyProvider extends Polymer.Element {
        static get is() {
            return 'provider-spotify';
        }

        static get properties() {
            return {
                _authToken: {
                    type: String
                }
            };
        }

        getPlaylists() {

        }

        getTrackInfo(id, market) {
            return this.getTracksInfo([id], market)
                .then(tracks => (tracks.length > 0) > 0 ? tracks[0] : null);
        }

        // This does not guarantee ordering!
        getTracksInfo(ids, market) {
            return this._fetchIds(_.without(ids, ...Object.keys(SpotifyProvider.cache)), market)
                .then(() => ids.map(id => SpotifyProvider.cache[id]));
        }

        search(query, market, limit) {
            if (query.length < 2) {
                return Promise.resolve([]);
            }

            let url = `https://api.spotify.com/v1/search?type=track&limit=${limit || 20}&q=${encodeURIComponent(query.replace('-', ' ') + '*')}`;
            if (market) {
                url += `&market=${market}`;
            }

            return this._fetchAuthed(url)
                .then(resp => resp.json())
                .then(resp => {
                    const tracks = _.get(resp, 'tracks.items', []);
                    tracks.forEach(t => SpotifyProvider.cache[t.id] = t);
                    return tracks.map(track => ({
                        reference: {
                            id: track.id,
                            provider: 'spotify'
                        }
                    }));
                });
        }

        _fetchIds(ids, market) {
            if (!ids || ids.length < 1) {
                return Promise.resolve([]);
            }

            let url = `https://api.spotify.com/v1/tracks?ids=${encodeURIComponent(ids.join(','))}`;
            if (market) {
                url += `&market=${market}`;
            }

            return this._fetchAuthed(url)
                .then(resp => resp.json())
                .then(resp => {
                    (resp.tracks || []).forEach(t => SpotifyProvider.cache[t.id] = t);
                    return tracks;
                });
        }

        _fetchAuthed(url, options) {
            if (!this._authToken) {
                const authUrl = this.get('state.config.spotify.clientTokenUrl');
                return fetch(authUrl)
                    .then(resp => resp.json())
                    .then(resp => this._authToken = resp.access_token)
                    .then(() => this._fetchAuthed(url, options));
            }

            return fetch(url, _.merge((options || {}), {
                headers: {
                    Authorization: `Bearer ${this._authToken}`
                }
            }))
                .then(resp => {
                    if (resp.status !== 401) {
                        return resp;
                    }

                    this._authToken = null;
                    return this._fetchAuthed(url, options);
                })
                .then(resp => {
                    if (resp.ok) {
                        return resp;
                    }

                    return Promise.reject(new Error(`Received invalid status code ${resp.status} from Spotify.`));
                });
        }
    }

    SpotifyProvider.cache = {};
    customElements.define(SpotifyProvider.is, SpotifyProvider);
</script>
